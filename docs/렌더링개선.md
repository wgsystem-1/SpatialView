# WPF GIS 다중 레이어 렌더링 최적화 설계 가이드
> 대상: 수십 개 Point / Polyline / Polygon(Multi, Hole 포함) 레이어 동시 로딩
> 전제: GDAL/OGR = 데이터 I/O 전용, WPF = 네이티브 렌더링

---

## 1. 문제 정의

### ❌ 일반적인 병목 원인
- 모든 레이어를 매 프레임 재렌더링
- Geometry 객체 과다 생성
- Viewport 외 피처까지 렌더링
- 스타일 변경 시 전체 재드로잉
- Pan/Zoom 시 벡터 재계산

➡ **레이어 수가 늘어날수록 CPU/GPU 급격히 소모**

---

## 2. 최적화 설계의 핵심 원칙 (요약)

| 구분 | 원칙 |
|----|----|
| 렌더링 | “그릴 것만 그린다” |
| 구조 | 레이어 단위 시각 객체 분리 |
| 데이터 | Viewport + LOD 기반 필터링 |
| 재사용 | Geometry / Bitmap 적극 캐시 |
| 갱신 | 변경된 레이어만 재렌더링 |

---

## 3. 전체 아키텍처 권장 구조

MapControl
├─ LayerManager
│ ├─ Layer (DrawingVisual)
│ │ ├─ GeometryCache
│ │ ├─ BitmapCache
│ │ └─ RenderState
│ └─ LayerRenderScheduler
└─ RenderContext
├─ World → Screen Transform
└─ Viewport(BBOX)

yaml
코드 복사

---

## 4. 레이어 단위 렌더링 전략 (핵심)

### ✅ 4.1 레이어 = DrawingVisual 1개

- 레이어마다 **독립된 DrawingVisual**
- 전체 Canvas를 다시 그리지 않음
- On/Off, Style 변경 시 해당 레이어만 갱신

```csharp
class MapLayerVisual : DrawingVisual
{
    public LayerRenderState State;
}
✅ 4.2 레이어 렌더 상태 분리
csharp
코드 복사
class LayerRenderState
{
    bool IsVisible;
    bool IsDirty;      // 재렌더 필요 여부
    bool IsCached;     // BitmapCache 사용 여부
    int LODLevel;
}
Pan → Dirty ❌

Zoom Level 변경 → Dirty ⭕

Style 변경 → Dirty ⭕

Visibility Toggle → Dirty ❌ (Show/Hide만)

5. Viewport + Spatial Filtering (필수)
5.1 Viewport 기반 Feature 필터링
렌더링 전 반드시 수행:

text
코드 복사
Feature.BBOX ∩ Viewport.BBOX == true
GDAL Feature 읽기 시 Spatial Filter 적용

또는 메모리 캐시 후 BBOX 비교

➡ 전체 피처의 80~95% 제거 효과

5.2 LOD(Level of Detail) 기준
축척	전략
소축척	Polygon 단순화 / 집계
중축척	기본 Geometry
대축척	Full Geometry + Label

Douglas-Peucker 단순화

포인트는 클러스터링

6. Geometry 생성 최적화
✅ 6.1 StreamGeometry만 사용
타입	사용 여부
PathGeometry	❌
StreamGeometry	⭕ (필수)

csharp
코드 복사
StreamGeometry geo = new();
geo.FillRule = FillRule.EvenOdd;
✅ 6.2 Geometry Freeze 필수
csharp
코드 복사
if (geo.CanFreeze)
    geo.Freeze();
메모리 감소

Render Thread 성능 향상

✅ 6.3 Multi / Hole Polygon 처리
Outer + Inner Ring 모두 하나의 StreamGeometry

FillRule = EvenOdd

csharp
코드 복사
BeginFigure(outer)
BeginFigure(hole1)
BeginFigure(hole2)
7. Bitmap Cache 전략 (가장 중요)
7.1 언제 BitmapCache를 쓰는가?
상황	사용 여부
Pan	⭕ (필수)
Style 변경	❌
Zoom 소폭	⭕
Zoom 단계 변경	❌

7.2 레이어 단위 캐시
csharp
코드 복사
layerVisual.CacheMode = new BitmapCache();
복잡한 Polygon 레이어 필수

배경 레이어(행정구역, 토지 등)에 특히 효과 큼

7.3 Cache 무효화 조건
text
코드 복사
- Zoom Level 변경
- Style 변경
- 데이터 변경
8. Point 레이어 최적화
8.1 개별 DrawEllipse ❌
수천 개 이상이면 성능 급락

8.2 Batch Geometry ⭕ (권장)
StreamGeometry에 다수 Point 묶기

심볼 크기는 Screen 기준

8.3 클러스터링
축척	전략
소축척	Grid / QuadTree
대축척	원본 Point

9. Polyline 레이어 최적화
동일 스타일 선은 하나의 Geometry로 묶기

Pen 재사용 (Freeze)

csharp
코드 복사
Pen roadPen = new Pen(Brushes.Gray, 1);
roadPen.Freeze();
10. 레이어 렌더링 스케줄링
❌ 즉시 렌더링
이벤트마다 바로 Draw

✅ 지연 렌더링 (권장)
text
코드 복사
- Pan 중 → Render 중지
- Pan 종료 → 한 번만 Render
DispatcherTimer / CompositionTarget.Rendering 활용

11. 성능 체감 효과 (실무 기준)
최적화 적용	FPS
미적용	5~10
Viewport + StreamGeometry	20~30
BitmapCache + Layer 분리	40~60
LOD + 클러스터링	60+

12. WPF 기반 한계 (명확히 인지)
대규모 실시간 벡터(수백만 피처)는 한계

GPU 직접 활용 불가

3D / 고성능은 DirectX/OpenGL 전환 필요

➡ 현재 아키텍처는 “2D GIS 편집·검수·제작 툴”에 최적

13. 결론 (실전 요약)
✔ 레이어 = DrawingVisual
✔ StreamGeometry + Freeze
✔ Viewport + LOD 필터링
✔ BitmapCache 적극 활용
✔ 변경된 레이어만 재렌더링
✔ Pan/Zoom 이벤트 분리 처리

➡ 수십 개 레이어 동시 오픈도 실사용 가능 수준 확보